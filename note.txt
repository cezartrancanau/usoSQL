./main nume_db
intra in baza de date (daca nu exista este creata)


CREATE TABLE Persons 
PersonID int
LastName char(255)
FirstName char(255)
Address char(255)
City char(255);
(tipurile de date o sa fie int, char(nr) si float)


INSERT INTO table_name
value1 value2 value3 ...;


UPDATE table_name
SET column1 = value1 column2 = value2 ...
WHERE condition;


SELECT column1 column2 ...
FROM table_name;


DELETE FROM table_name WHERE condition;


DROP DATABASE nume_db
(sterge baza de date)

Pentru B-Tree:
    Fiecare tabel are doua fisiere: 
      unul cu datele b-tree-ului asociat
      unul cu datele din tabel

      Fisierul arborelui:
        Contine datele nodurilor + pozitii in fisier unde se pot adauga noi noduri
        
        Nodurile pot fi puse in orice ordine
        
        "Pointerii" catre child nodes sunt de fapt 
        offset-ul din fisier al nodului respectiv
        (La al catelea byte din fisier este stocat nodul?)

        Stergerea marcheaza spatiul din fisier al unui nod drept "nefolosit".
        Pozitiile nodurilor nefolosite sunt stocate 
          a) intr-un array la inceputul/finalul fisierului.
          sau (o idee mai buna)
          b) intr-un queue retinut in RAM

        Inserarea noilor noduri in arbore se face in functie de pozitiile din array/queue.

        Fiecare leaf node contine offset-ul unei pagini (definite mai jos)
        din fisierul cu date ale tabelului.

        Nodurile sunt ordonate dupa id-ul primei linii de pe pagina asociata acestuia.


      Fisierul cu datele din tabel:
        Este impartit in pagini (blocuri de 4096 bytes)
        
        Fiecare pagina contine mai multe linii din tabel
        (liniile nu vor fi impartite pe mai multe pagini)

        Liniile dintr-o pagina sunt ordonate dupa id

        Daca o pagina este plina, se creeaza o noua pagina, se insereaza acolo.
        (Ordinea paginilor in fisier nu conteaza)

        Daca se sterge singurul element ramas intr-o pagina, aceasta este marcata drept
        "nefolosita". (Paginile se adauga la fel ca nodurile din b-tree)
        De asemenea, se sterge nodul ei din b-tree.

Exemplu:
Tabel Persoane
+----+-------------------+
| id |      int64_t      |
+----+-------------------+
|nume|char array (max 30)|
+----+-------------------+

Fisiere:
  persoane.db  (pentru linii)
  persoane.arb (pentru arbore)

Obiecte la runtime:
  queue db_insert_q (queue pentru spatii libere in fisierul persoane.db)
  queue arb_insert_q (queue pentru spatii libere in fisierul persoane.arb)

Ambele queue-uri sunt goale

La inceputul fisierului persoane.db se afla doar numele coloanelor
(ocupa 7 bytes in exemplu, deci prima pagina apare la al 8-lea byte)

Structura unui nod in arbore:
  keys (array, contine id-ul paginilor)
  child_pointers (array de pointeri)
  page_pointers (array, offset-urile paginilor asociate cheilor)

  Pentru exemplu, un nod are doar 2 chei/valori si 3 pointeri

La inceput fisierul persoane.arb contine un singur nod:
Nod1:
  keys: [-1, -1]
  child_pointers: [NULL, NULL, NULL]
  page_pointers: [-1, -1]


Operatii:
  1)  insert 1 claudiu (1 = id, claudiu = nume)

      Se cauta pozitia din arbore unde se va adauga noua linie
      Se creeaza o noua pagina in persoane.db (la al 8-lea byte)


      Fisierul persoane.arb devine
      (Nod1)
      +-+--+--+--+--+-+--+
      |1|-1|-1|-1|-1|8|-1|
      +-+--+--+--+--+-+--+
      | ^  |   ^    | ^------ |
      | |  |   |    |       | |
      keys, child_pointers, page_pointers


      Fisierul persoane.db devine
      +------+--------+-+------------------+
      |"id\0"|"nume\0"|1|"claudiu\0       "|
      +------+--------+-+------------------+
      (spatiu adaugat pentru ca numele ocupa 30 bytes)



  2)  insert 2 raul
     
      Presupunem ca o pagina retine o singura linie

      Fisierul persoane.db devine
      +------+--------+-+------------------+
      |"id\0"|"nume\0"|1|"claudiu\0       "|
      +------+--------+-+------------------+
      +-+----------------+
      |2|"raul\0        "|
      +-+----------------+

      Fisierul persoane.arb devine
      (Nod1)
      +-+-+--+--+--+-+--+
      |1|2|-1|-1|-1|8|46|
      +-+-+--+--+--+-+--+
      | ^ |   ^    |  ^------ |
      | | |   |    |        | |
      keys, child_pointers, page_pointers

      Noua pagina va avea cheia 2 si offset-ul 46



  3)  insert 3 octavian

      Fisierul persoane.arb devine
      (Nod1)
      +-+--+--+--+--+-+--+
      |1|-1|-1|-1|-1|8|-1|
      +-+--+--+--+--+-+--+
      | ^  |   ^    |  ^------ |
      | |  |   |    |        | |
      keys, child_pointers, page_pointers

      (Nod2)
      +-+--+-+---+--+--+--+
      |2|-1|0|112|-1|46|-1|
      +-+--+-+---+--+--+--+
      | ^  |   ^    |  ^------ |
      | |  |   |    |        | |
      keys, child_pointers, page_pointers
      ->0 este offsetul primului nod
      ->112 este offsetul celui de al treilea nod
      
      (Nod3)
      +-+--+--+--+--+--+--+
      |3|-1|-1|-1|-1|84|-1|
      +-+--+--+--+--+--+--+
      | ^  |   ^    |  ^------ |
      | |  |   |    |        | |
      keys, child_pointers, page_pointers


      Fisierul persoane.db devine
      +------+--------+-+------------------+
      |"id\0"|"nume\0"|1|"claudiu\0       "|
      +------+--------+-+------------------+
      +-+----------------+
      |2|"raul\0        "|
      +-+----------------+
      +-+----------------+
      |3|"octavian\0    "|
      +-+----------------+



  4)  remove from persoane 1 (sterge dupa index)

      Ultima linie de pe pagina 1 este stearsa, deci pagina este libera
      In db_insert_q se da push la offset-ul paginii (8)


      Fisierul persoane.db devine
      +------+--------+--+------------------+
      |"id\0"|"nume\0"|-1|"claudiu\0       "|
      +------+--------+--+------------------+
      +-+----------------+
      |2|"raul\0        "|
      +-+----------------+
      +-+----------------+
      |3|"octavian\0    "|
      +-+----------------+
      id-ul -1 semnaleaza ca pagina nu e folosita


      Nodul in care are pointer la pagina 1 nu mai are pagini, deci este sters
      In arb_insert_q se da push la offset-ul nodului (0)

      
      Fisierul persoane.arb devine
      (Nod1)
      +--+--+--+--+--+-+--+
      |-1|-1|-1|-1|-1|8|-1|
      +--+--+--+--+--+-+--+
      | ^   |   ^    |  ^------ |
      | |   |   |    |        | |
      keys, child_pointers, page_pointers

      (Nod2)
      +-+--+-+---+--+--+--+
      |2|-1|0|112|-1|46|-1|
      +-+--+-+---+--+--+--+
      | ^  |   ^    |  ^------ |
      | |  |   |    |        | |
      keys, child_pointers, page_pointers
      ->0 este offsetul primului nod
      ->112 este offsetul celui de al treilea nod
      
      (Nod3)
      +-+--+--+--+--+--+--+
      |3|-1|-1|-1|-1|84|-1|
      +-+--+--+--+--+--+--+
      | ^  |   ^    |  ^------ |
      | |  |   |    |        | |
      keys, child_pointers, page_pointers



  5)  insert 1 claudiu
      
      db_insert_q nu este gol, deci noua pagina va aparea la offset-ul
      determinat de primul element din queue (care este scos dupa)
      La fel si pentru noul nod cu arb_insert_q

      
      Fisierele persoane.arb si persoane.db sunt identice cu cele de la pasul 3)
      Cele doua queue-uri sunt goale